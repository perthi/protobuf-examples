/* Automatically generated nanopb constant definitions */
/* Generated by nanopb-0.3.9-dev at Wed Nov 27 12:12:09 2019. */

#include "kf.pb.h"

/* @@protoc_insertion_point(includes) */
#if PB_PROTO_HEADER_VERSION != 30
#error Regenerate this file with the current version of nanopb generator.
#endif



const pb_field_t SEMValue_fields[2] = {
    PB_FIELD(  1, FLOAT   , REQUIRED, STATIC  , FIRST, SEMValue, f_val, f_val, 0),
    PB_LAST_FIELD
};

const pb_field_t SEMXYValue_fields[3] = {
    PB_FIELD(  1, FLOAT   , REQUIRED, STATIC  , FIRST, SEMXYValue, x, x, 0),
    PB_FIELD(  2, FLOAT   , REQUIRED, STATIC  , OTHER, SEMXYValue, y, x, 0),
    PB_LAST_FIELD
};

const pb_field_t SEMCrc_fields[2] = {
    PB_FIELD(  1, INT32   , REQUIRED, STATIC  , FIRST, SEMCrc, crc, crc, 0),
    PB_LAST_FIELD
};

const pb_field_t SEMCommand_fields[5] = {
    PB_FIELD(  1, STRING  , REQUIRED, STATIC  , FIRST, SEMCommand, device_id, device_id, 0),
    PB_FIELD(  2, INT32   , REQUIRED, STATIC  , OTHER, SEMCommand, cmd_id, device_id, 0),
    PB_ONEOF_FIELD(payload,   4, MESSAGE , ONEOF, STATIC  , OTHER, SEMCommand, val, cmd_id, &SEMValue_fields),
    PB_ONEOF_FIELD(payload,   5, MESSAGE , ONEOF, STATIC  , UNION, SEMCommand, xy, cmd_id, &SEMXYValue_fields),
    PB_LAST_FIELD
};

const pb_field_t SEMMessageStatus_fields[5] = {
    PB_FIELD(  1, INT32   , REQUIRED, STATIC  , FIRST, SEMMessageStatus, state, state, 0),
    PB_FIELD(  2, INT32   , OPTIONAL, STATIC  , OTHER, SEMMessageStatus, configuration_crc, state, 0),
    PB_FIELD(  3, INT32   , OPTIONAL, STATIC  , OTHER, SEMMessageStatus, error_code, configuration_crc, 0),
    PB_FIELD(  4, STRING  , OPTIONAL, STATIC  , OTHER, SEMMessageStatus, error_string, error_code, 0),
    PB_LAST_FIELD
};

const pb_field_t SEMMessageSensor_fields[7] = {
    PB_FIELD(  1, INT32   , REQUIRED, STATIC  , FIRST, SEMMessageSensor, state, state, 0),
    PB_FIELD(  2, FLOAT   , REQUIRED, STATIC  , OTHER, SEMMessageSensor, value_converted, state, 0),
    PB_FIELD(  3, INT32   , OPTIONAL, STATIC  , OTHER, SEMMessageSensor, value_raw, value_converted, 0),
    PB_FIELD(  4, INT32   , REQUIRED, STATIC  , OTHER, SEMMessageSensor, alarm_status, value_raw, 0),
    PB_FIELD(  5, INT32   , OPTIONAL, STATIC  , OTHER, SEMMessageSensor, error_code, alarm_status, 0),
    PB_FIELD(  6, STRING  , OPTIONAL, STATIC  , OTHER, SEMMessageSensor, error_string, error_code, 0),
    PB_LAST_FIELD
};

const pb_field_t SEMMessageSensorBool_fields[6] = {
    PB_FIELD(  1, INT32   , REQUIRED, STATIC  , FIRST, SEMMessageSensorBool, state, state, 0),
    PB_FIELD(  2, INT32   , REQUIRED, STATIC  , OTHER, SEMMessageSensorBool, value_converted, state, 0),
    PB_FIELD(  3, INT32   , OPTIONAL, STATIC  , OTHER, SEMMessageSensorBool, value_raw, value_converted, 0),
    PB_FIELD(  5, INT32   , OPTIONAL, STATIC  , OTHER, SEMMessageSensorBool, error_code, value_raw, 0),
    PB_FIELD(  6, STRING  , OPTIONAL, STATIC  , OTHER, SEMMessageSensorBool, error_string, error_code, 0),
    PB_LAST_FIELD
};

const pb_field_t SEMMessageMotor_fields[8] = {
    PB_FIELD(  1, INT32   , REQUIRED, STATIC  , FIRST, SEMMessageMotor, state, state, 0),
    PB_FIELD(  2, FLOAT   , REQUIRED, STATIC  , OTHER, SEMMessageMotor, value_position, state, 0),
    PB_FIELD(  3, FLOAT   , OPTIONAL, STATIC  , OTHER, SEMMessageMotor, value_speed, value_position, 0),
    PB_FIELD(  4, BOOL    , OPTIONAL, STATIC  , OTHER, SEMMessageMotor, end_stop_reached, value_speed, 0),
    PB_FIELD(  5, BOOL    , OPTIONAL, STATIC  , OTHER, SEMMessageMotor, home_position_reached, end_stop_reached, 0),
    PB_FIELD(  6, INT32   , OPTIONAL, STATIC  , OTHER, SEMMessageMotor, error_code, home_position_reached, 0),
    PB_FIELD(  7, STRING  , OPTIONAL, STATIC  , OTHER, SEMMessageMotor, error_string, error_code, 0),
    PB_LAST_FIELD
};

const pb_field_t SEMMessageSolenoid_fields[4] = {
    PB_FIELD(  1, INT32   , REQUIRED, STATIC  , FIRST, SEMMessageSolenoid, state, state, 0),
    PB_FIELD(  2, INT32   , OPTIONAL, STATIC  , OTHER, SEMMessageSolenoid, error_code, state, 0),
    PB_FIELD(  3, STRING  , OPTIONAL, STATIC  , OTHER, SEMMessageSolenoid, error_string, error_code, 0),
    PB_LAST_FIELD
};

const pb_field_t SEMMessageXYMotor_fields[6] = {
    PB_FIELD(  1, INT32   , REQUIRED, STATIC  , FIRST, SEMMessageXYMotor, state, state, 0),
    PB_FIELD(  2, FLOAT   , REQUIRED, STATIC  , OTHER, SEMMessageXYMotor, value_x_position, state, 0),
    PB_FIELD(  3, FLOAT   , REQUIRED, STATIC  , OTHER, SEMMessageXYMotor, value_y_position, value_x_position, 0),
    PB_FIELD(  4, INT32   , OPTIONAL, STATIC  , OTHER, SEMMessageXYMotor, error_code, value_y_position, 0),
    PB_FIELD(  5, STRING  , OPTIONAL, STATIC  , OTHER, SEMMessageXYMotor, error_string, error_code, 0),
    PB_LAST_FIELD
};

const pb_field_t SEMMessageConfigurationStatusReply_fields[3] = {
    PB_FIELD(  2, INT32   , OPTIONAL, STATIC  , FIRST, SEMMessageConfigurationStatusReply, error_code, error_code, 0),
    PB_FIELD(  3, STRING  , OPTIONAL, STATIC  , OTHER, SEMMessageConfigurationStatusReply, error_string, error_code, 0),
    PB_LAST_FIELD
};

const pb_field_t SEMMessageCommandStatusReply_fields[3] = {
    PB_FIELD(  5, INT32   , OPTIONAL, STATIC  , FIRST, SEMMessageCommandStatusReply, error_code, error_code, 0),
    PB_FIELD(  6, STRING  , OPTIONAL, STATIC  , OTHER, SEMMessageCommandStatusReply, error_string, error_code, 0),
    PB_LAST_FIELD
};

const pb_field_t SEMMessage_fields[10] = {
    PB_FIELD(  1, STRING  , REQUIRED, STATIC  , FIRST, SEMMessage, device_id, device_id, 0),
    PB_ONEOF_FIELD(payload,   3, MESSAGE , ONEOF, STATIC  , OTHER, SEMMessage, sem_status, device_id, &SEMMessageStatus_fields),
    PB_ONEOF_FIELD(payload,   4, MESSAGE , ONEOF, STATIC  , UNION, SEMMessage, sensor_status, device_id, &SEMMessageSensor_fields),
    PB_ONEOF_FIELD(payload,   5, MESSAGE , ONEOF, STATIC  , UNION, SEMMessage, bool_sensor_status, device_id, &SEMMessageSensorBool_fields),
    PB_ONEOF_FIELD(payload,   6, MESSAGE , ONEOF, STATIC  , UNION, SEMMessage, motor_status, device_id, &SEMMessageMotor_fields),
    PB_ONEOF_FIELD(payload,   7, MESSAGE , ONEOF, STATIC  , UNION, SEMMessage, solenoid_status, device_id, &SEMMessageSolenoid_fields),
    PB_ONEOF_FIELD(payload,   8, MESSAGE , ONEOF, STATIC  , UNION, SEMMessage, xy_motor_status, device_id, &SEMMessageXYMotor_fields),
    PB_ONEOF_FIELD(payload,   9, MESSAGE , ONEOF, STATIC  , UNION, SEMMessage, configuration_reply, device_id, &SEMMessageConfigurationStatusReply_fields),
    PB_ONEOF_FIELD(payload,  10, MESSAGE , ONEOF, STATIC  , UNION, SEMMessage, command_reply, device_id, &SEMMessageCommandStatusReply_fields),
    PB_LAST_FIELD
};

const pb_field_t SEMConfig_fields[9] = {
    PB_FIELD(  1, MESSAGE , REQUIRED, STATIC  , FIRST, SEMConfig, address, address, &SEMDeviceAddress_fields),
    PB_ONEOF_FIELD(device,   2, MESSAGE , ONEOF, STATIC  , OTHER, SEMConfig, sem, address, &SEMConfigSEM_fields),
    PB_ONEOF_FIELD(device,   3, MESSAGE , ONEOF, STATIC  , UNION, SEMConfig, motor_stepper, address, &SEMConfigStepperMotor_fields),
    PB_ONEOF_FIELD(device,   4, MESSAGE , ONEOF, STATIC  , UNION, SEMConfig, motor_xy, address, &SEMConfigVirtualXYMotors_fields),
    PB_ONEOF_FIELD(device,   5, MESSAGE , ONEOF, STATIC  , UNION, SEMConfig, solenoid, address, &SEMConfigSolenoid_fields),
    PB_ONEOF_FIELD(device,   6, MESSAGE , ONEOF, STATIC  , UNION, SEMConfig, pwm, address, &SEMConfigPWM_fields),
    PB_ONEOF_FIELD(device,   7, MESSAGE , ONEOF, STATIC  , UNION, SEMConfig, sensor_analog, address, &SEMConfigSensorAnalog_fields),
    PB_ONEOF_FIELD(device,   8, MESSAGE , ONEOF, STATIC  , UNION, SEMConfig, sensor_bool, address, &SEMConfigSensorBool_fields),
    PB_LAST_FIELD
};

const pb_field_t SEMDeviceAddress_fields[6] = {
    PB_FIELD(  1, STRING  , REQUIRED, STATIC  , FIRST, SEMDeviceAddress, device_id, device_id, 0),
    PB_FIELD(  2, STRING  , OPTIONAL, STATIC  , OTHER, SEMDeviceAddress, device_name, device_id, 0),
    PB_FIELD(  3, INT32   , REQUIRED, STATIC  , OTHER, SEMDeviceAddress, card_id, device_name, 0),
    PB_FIELD(  4, INT32   , REQUIRED, STATIC  , OTHER, SEMDeviceAddress, device_port_no, card_id, 0),
    PB_FIELD(  5, INT32   , OPTIONAL, STATIC  , OTHER, SEMDeviceAddress, device_type, device_port_no, 0),
    PB_LAST_FIELD
};

const pb_field_t SEMStepUnitConversion_fields[3] = {
    PB_FIELD(  1, INT32   , REQUIRED, STATIC  , FIRST, SEMStepUnitConversion, si_unit, si_unit, 0),
    PB_FIELD(  2, FLOAT   , REQUIRED, STATIC  , OTHER, SEMStepUnitConversion, unit_per_step, si_unit, 0),
    PB_LAST_FIELD
};

const pb_field_t SEMLinearUnitConversion_fields[6] = {
    PB_FIELD(  1, INT32   , REQUIRED, STATIC  , FIRST, SEMLinearUnitConversion, input_type, input_type, 0),
    PB_FIELD(  2, FLOAT   , REQUIRED, STATIC  , OTHER, SEMLinearUnitConversion, min_input, input_type, 0),
    PB_FIELD(  3, FLOAT   , REQUIRED, STATIC  , OTHER, SEMLinearUnitConversion, max_input, min_input, 0),
    PB_FIELD(  4, FLOAT   , REQUIRED, STATIC  , OTHER, SEMLinearUnitConversion, min_output, max_input, 0),
    PB_FIELD(  5, FLOAT   , REQUIRED, STATIC  , OTHER, SEMLinearUnitConversion, max_output, min_output, 0),
    PB_LAST_FIELD
};

const pb_field_t SEMThresholds_fields[5] = {
    PB_FIELD(  1, FLOAT   , OPTIONAL, STATIC  , FIRST, SEMThresholds, alarm_low, alarm_low, 0),
    PB_FIELD(  2, FLOAT   , OPTIONAL, STATIC  , OTHER, SEMThresholds, warning_low, alarm_low, 0),
    PB_FIELD(  3, FLOAT   , OPTIONAL, STATIC  , OTHER, SEMThresholds, warning_high, warning_low, 0),
    PB_FIELD(  4, FLOAT   , OPTIONAL, STATIC  , OTHER, SEMThresholds, alarm_high, warning_high, 0),
    PB_LAST_FIELD
};

const pb_field_t SEMConfigSEM_fields[7] = {
    PB_FIELD(  1, STRING  , REQUIRED, CALLBACK, FIRST, SEMConfigSEM, name, name, 0),
    PB_FIELD(  2, INT32   , OPTIONAL, STATIC  , OTHER, SEMConfigSEM, enable_wifi, name, 0),
    PB_FIELD(  3, INT32   , REPEATED, CALLBACK, OTHER, SEMConfigSEM, ethernet_address, enable_wifi, 0),
    PB_FIELD(  4, INT32   , REPEATED, CALLBACK, OTHER, SEMConfigSEM, ethernet_mask, ethernet_address, 0),
    PB_FIELD(  5, INT32   , REPEATED, CALLBACK, OTHER, SEMConfigSEM, ethernet_default_gateway, ethernet_mask, 0),
    PB_FIELD(  6, INT32   , REPEATED, CALLBACK, OTHER, SEMConfigSEM, dnsServerAddress, ethernet_default_gateway, 0),
    PB_LAST_FIELD
};

const pb_field_t SEMConfigStepperMotor_fields[18] = {
    PB_FIELD(  1, MESSAGE , REQUIRED, STATIC  , FIRST, SEMConfigStepperMotor, conversion, conversion, &SEMStepUnitConversion_fields),
    PB_FIELD(  2, INT32   , REQUIRED, STATIC  , OTHER, SEMConfigStepperMotor, direction_positive, conversion, 0),
    PB_FIELD(  3, FLOAT   , OPTIONAL, STATIC  , OTHER, SEMConfigStepperMotor, negative_soft_endstop, direction_positive, 0),
    PB_FIELD(  4, FLOAT   , OPTIONAL, STATIC  , OTHER, SEMConfigStepperMotor, positive_soft_endstop, negative_soft_endstop, 0),
    PB_FIELD(  5, FLOAT   , OPTIONAL, STATIC  , OTHER, SEMConfigStepperMotor, max_speed, positive_soft_endstop, 0),
    PB_FIELD(  6, FLOAT   , OPTIONAL, STATIC  , OTHER, SEMConfigStepperMotor, speed, max_speed, 0),
    PB_FIELD(  7, FLOAT   , OPTIONAL, STATIC  , OTHER, SEMConfigStepperMotor, max_acceleration, speed, 0),
    PB_FIELD(  8, FLOAT   , OPTIONAL, STATIC  , OTHER, SEMConfigStepperMotor, acceleration, max_acceleration, 0),
    PB_FIELD(  9, FLOAT   , OPTIONAL, STATIC  , OTHER, SEMConfigStepperMotor, max_current, acceleration, 0),
    PB_FIELD( 10, FLOAT   , OPTIONAL, STATIC  , OTHER, SEMConfigStepperMotor, current, max_current, 0),
    PB_FIELD( 11, FLOAT   , OPTIONAL, STATIC  , OTHER, SEMConfigStepperMotor, inactive_timeout, current, 0),
    PB_FIELD( 12, FLOAT   , OPTIONAL, STATIC  , OTHER, SEMConfigStepperMotor, inactive_current, inactive_timeout, 0),
    PB_FIELD( 13, FLOAT   , OPTIONAL, STATIC  , OTHER, SEMConfigStepperMotor, home_value, inactive_current, 0),
    PB_FIELD( 14, STRING  , OPTIONAL, STATIC  , OTHER, SEMConfigStepperMotor, home_device_id, home_value, 0),
    PB_FIELD( 15, INT32   , OPTIONAL, STATIC  , OTHER, SEMConfigStepperMotor, direction_home, home_device_id, 0),
    PB_FIELD( 16, STRING  , OPTIONAL, STATIC  , OTHER, SEMConfigStepperMotor, negative_soft_endstop_id, direction_home, 0),
    PB_FIELD( 17, STRING  , OPTIONAL, STATIC  , OTHER, SEMConfigStepperMotor, positive_soft_endstop_id, negative_soft_endstop_id, 0),
    PB_LAST_FIELD
};

const pb_field_t SEMConfigVirtualXYMotors_fields[3] = {
    PB_FIELD(  1, STRING  , REQUIRED, STATIC  , FIRST, SEMConfigVirtualXYMotors, device_id_x, device_id_x, 0),
    PB_FIELD(  2, STRING  , REQUIRED, STATIC  , OTHER, SEMConfigVirtualXYMotors, device_id_y, device_id_x, 0),
    PB_LAST_FIELD
};

const pb_field_t SEMConfigSolenoid_fields[4] = {
    PB_FIELD(  1, FLOAT   , OPTIONAL, STATIC  , FIRST, SEMConfigSolenoid, max_current, max_current, 0),
    PB_FIELD(  2, FLOAT   , OPTIONAL, STATIC  , OTHER, SEMConfigSolenoid, activate_current, max_current, 0),
    PB_FIELD(  3, FLOAT   , OPTIONAL, STATIC  , OTHER, SEMConfigSolenoid, hold_current, activate_current, 0),
    PB_LAST_FIELD
};

const pb_field_t SEMConfigPWM_fields[4] = {
    PB_FIELD(  1, MESSAGE , REQUIRED, STATIC  , FIRST, SEMConfigPWM, conversion, conversion, &SEMLinearUnitConversion_fields),
    PB_FIELD(  3, FLOAT   , OPTIONAL, STATIC  , OTHER, SEMConfigPWM, min_level, conversion, 0),
    PB_FIELD(  4, FLOAT   , OPTIONAL, STATIC  , OTHER, SEMConfigPWM, max_level, min_level, 0),
    PB_LAST_FIELD
};

const pb_field_t SEMConfigSensorAnalog_fields[5] = {
    PB_FIELD(  1, MESSAGE , OPTIONAL, STATIC  , FIRST, SEMConfigSensorAnalog, conversion, conversion, &SEMLinearUnitConversion_fields),
    PB_FIELD(  2, MESSAGE , OPTIONAL, STATIC  , OTHER, SEMConfigSensorAnalog, thresholds, conversion, &SEMThresholds_fields),
    PB_FIELD(  3, INT32   , OPTIONAL, STATIC  , OTHER, SEMConfigSensorAnalog, input_type, thresholds, 0),
    PB_FIELD(  4, STRING  , OPTIONAL, STATIC  , OTHER, SEMConfigSensorAnalog, device_id_aux, input_type, 0),
    PB_LAST_FIELD
};

const pb_field_t SEMConfigSensorBool_fields[5] = {
    PB_FIELD(  1, INT32   , OPTIONAL, STATIC  , FIRST, SEMConfigSensorBool, signal_type, signal_type, 0),
    PB_FIELD(  2, BOOL    , OPTIONAL, STATIC  , OTHER, SEMConfigSensorBool, active_high, signal_type, 0),
    PB_FIELD(  3, BOOL    , OPTIONAL, STATIC  , OTHER, SEMConfigSensorBool, alarm, active_high, 0),
    PB_FIELD(  4, STRING  , OPTIONAL, STATIC  , OTHER, SEMConfigSensorBool, device_id_aux, alarm, 0),
    PB_LAST_FIELD
};

const pb_field_t SEMOneOfMessage_fields[5] = {
    PB_FIELD(  1, INT32   , REQUIRED, STATIC  , FIRST, SEMOneOfMessage, sequence_id, sequence_id, 0),
    PB_ONEOF_FIELD(payload,   2, MESSAGE , ONEOF, STATIC  , OTHER, SEMOneOfMessage, sem_config, sequence_id, &SEMConfig_fields),
    PB_ONEOF_FIELD(payload,   3, MESSAGE , ONEOF, STATIC  , UNION, SEMOneOfMessage, sem_command, sequence_id, &SEMCommand_fields),
    PB_ONEOF_FIELD(payload,   4, MESSAGE , ONEOF, STATIC  , UNION, SEMOneOfMessage, sem_message, sequence_id, &SEMMessage_fields),
    PB_LAST_FIELD
};


/* Check that field information fits in pb_field_t */
#if !defined(PB_FIELD_32BIT)
/* If you get an error here, it means that you need to define PB_FIELD_32BIT
 * compile-time option. You can do that in pb.h or on compiler command line.
 * 
 * The reason you need to do this is that some of your messages contain tag
 * numbers or field sizes that are larger than what can fit in 8 or 16 bit
 * field descriptors.
 */
PB_STATIC_ASSERT((pb_membersize(SEMCommand, payload.val) < 65536 && pb_membersize(SEMCommand, payload.xy) < 65536 && pb_membersize(SEMMessage, payload.sem_status) < 65536 && pb_membersize(SEMMessage, payload.sensor_status) < 65536 && pb_membersize(SEMMessage, payload.bool_sensor_status) < 65536 && pb_membersize(SEMMessage, payload.motor_status) < 65536 && pb_membersize(SEMMessage, payload.solenoid_status) < 65536 && pb_membersize(SEMMessage, payload.xy_motor_status) < 65536 && pb_membersize(SEMMessage, payload.configuration_reply) < 65536 && pb_membersize(SEMMessage, payload.command_reply) < 65536 && pb_membersize(SEMConfig, device.sem) < 65536 && pb_membersize(SEMConfig, device.motor_stepper) < 65536 && pb_membersize(SEMConfig, device.motor_xy) < 65536 && pb_membersize(SEMConfig, device.solenoid) < 65536 && pb_membersize(SEMConfig, device.pwm) < 65536 && pb_membersize(SEMConfig, device.sensor_analog) < 65536 && pb_membersize(SEMConfig, device.sensor_bool) < 65536 && pb_membersize(SEMConfig, address) < 65536 && pb_membersize(SEMConfigStepperMotor, conversion) < 65536 && pb_membersize(SEMConfigPWM, conversion) < 65536 && pb_membersize(SEMConfigSensorAnalog, conversion) < 65536 && pb_membersize(SEMConfigSensorAnalog, thresholds) < 65536 && pb_membersize(SEMOneOfMessage, payload.sem_config) < 65536 && pb_membersize(SEMOneOfMessage, payload.sem_command) < 65536 && pb_membersize(SEMOneOfMessage, payload.sem_message) < 65536), YOU_MUST_DEFINE_PB_FIELD_32BIT_FOR_MESSAGES_SEMValue_SEMXYValue_SEMCrc_SEMCommand_SEMMessageStatus_SEMMessageSensor_SEMMessageSensorBool_SEMMessageMotor_SEMMessageSolenoid_SEMMessageXYMotor_SEMMessageConfigurationStatusReply_SEMMessageCommandStatusReply_SEMMessage_SEMConfig_SEMDeviceAddress_SEMStepUnitConversion_SEMLinearUnitConversion_SEMThresholds_SEMConfigSEM_SEMConfigStepperMotor_SEMConfigVirtualXYMotors_SEMConfigSolenoid_SEMConfigPWM_SEMConfigSensorAnalog_SEMConfigSensorBool_SEMOneOfMessage)
#endif

#if !defined(PB_FIELD_16BIT) && !defined(PB_FIELD_32BIT)
/* If you get an error here, it means that you need to define PB_FIELD_16BIT
 * compile-time option. You can do that in pb.h or on compiler command line.
 * 
 * The reason you need to do this is that some of your messages contain tag
 * numbers or field sizes that are larger than what can fit in the default
 * 8 bit descriptors.
 */
PB_STATIC_ASSERT((pb_membersize(SEMCommand, payload.val) < 256 && pb_membersize(SEMCommand, payload.xy) < 256 && pb_membersize(SEMMessage, payload.sem_status) < 256 && pb_membersize(SEMMessage, payload.sensor_status) < 256 && pb_membersize(SEMMessage, payload.bool_sensor_status) < 256 && pb_membersize(SEMMessage, payload.motor_status) < 256 && pb_membersize(SEMMessage, payload.solenoid_status) < 256 && pb_membersize(SEMMessage, payload.xy_motor_status) < 256 && pb_membersize(SEMMessage, payload.configuration_reply) < 256 && pb_membersize(SEMMessage, payload.command_reply) < 256 && pb_membersize(SEMConfig, device.sem) < 256 && pb_membersize(SEMConfig, device.motor_stepper) < 256 && pb_membersize(SEMConfig, device.motor_xy) < 256 && pb_membersize(SEMConfig, device.solenoid) < 256 && pb_membersize(SEMConfig, device.pwm) < 256 && pb_membersize(SEMConfig, device.sensor_analog) < 256 && pb_membersize(SEMConfig, device.sensor_bool) < 256 && pb_membersize(SEMConfig, address) < 256 && pb_membersize(SEMConfigStepperMotor, conversion) < 256 && pb_membersize(SEMConfigPWM, conversion) < 256 && pb_membersize(SEMConfigSensorAnalog, conversion) < 256 && pb_membersize(SEMConfigSensorAnalog, thresholds) < 256 && pb_membersize(SEMOneOfMessage, payload.sem_config) < 256 && pb_membersize(SEMOneOfMessage, payload.sem_command) < 256 && pb_membersize(SEMOneOfMessage, payload.sem_message) < 256), YOU_MUST_DEFINE_PB_FIELD_16BIT_FOR_MESSAGES_SEMValue_SEMXYValue_SEMCrc_SEMCommand_SEMMessageStatus_SEMMessageSensor_SEMMessageSensorBool_SEMMessageMotor_SEMMessageSolenoid_SEMMessageXYMotor_SEMMessageConfigurationStatusReply_SEMMessageCommandStatusReply_SEMMessage_SEMConfig_SEMDeviceAddress_SEMStepUnitConversion_SEMLinearUnitConversion_SEMThresholds_SEMConfigSEM_SEMConfigStepperMotor_SEMConfigVirtualXYMotors_SEMConfigSolenoid_SEMConfigPWM_SEMConfigSensorAnalog_SEMConfigSensorBool_SEMOneOfMessage)
#endif


/* @@protoc_insertion_point(eof) */
