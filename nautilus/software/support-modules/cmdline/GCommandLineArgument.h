// -*- mode: c++ -*-
#ifndef COMMANDLINEGArgument_H
#define COMMANDLINEGArgument_H

/***************************************************************************
***          Author: Per Thomas Hille <pth@embc.no>                     ****
****************************************************************************/

/****************************************************************************
*** Copyright(C) 2018  Per Thomas Hille, pth@embc.no                      ***
*** This file is part of logmaster.logmaster is free software : you can   ***
*** redistribute it and / or modify it under the terms of the Lesser GNU  ***
*** General Public License(LGPL) V3 or later.See.cpp file for details     ***
*****************************************************************************/

#include <utilities/GDataTypes.h>
#include <utilities/GDefinitions.h>
#include <logging/LLogging.h>
#include "GArgument.h"

#include <vector>
#include <iostream>
#include <typeinfo>
#include <stdio.h>
#include <string.h>
#include <sstream>
#include <type_traits>


#include <logging/LPublisher.h>


using namespace LOGMASTER;
using namespace std;

/** @brief base class for all command line arguments */
template <typename T>
class GCommandLineArgument : public GArgument
{

public:

    /** Main constructor.
    * @param  name    the identifier of the command line argument, i.e the identifier used on the command line  
    * @param  usage    short description of the usage of the parameter.
    * @param  helptxt more elaborate description of the usage of the parameter
    * @tparam T  The type of the argument value
    * @param  arg     a pointer to the variable to be scanned from the commandline. It can be a zero pointer in which case no value is read from the commandline
    * @param  ismandatory  wether or not a parameter is mandatory, If a commandline argument is marked as mandatotor, and it is not present on the commandline, then the command line handliong system will throw an exception.
    * @param  funct An optional validation function. It takes as an argument the coommanline tag (referenced by the variable "name" ) and a vector of sub commands (sub) and  parameters (par). The vector
    * of subcommand and parameters are automatically generated by the system. The function pointer can be a zero pointer in which case no validation check is performed. */
	GCommandLineArgument <T >(	const string name, const string usage, const string helptxt, T *arg, const bool ismandatory =false, 
								std::function< bool(const string cmnd, const string args_s, const vector<string> sub, const vector<string> par)> funct = 0) : 
                                GArgument(name,
                                usage,   
                                helptxt,
                                ismandatory,
                                funct),
                                fParameter(arg)
    {
                SetTypeId();
    }


	GCommandLineArgument <T >(const string name, T *arg,  const bool ismandatory  = false) : GCommandLineArgument(name, "", "", arg, ismandatory, 0)
    {

    }


	virtual ~GCommandLineArgument();
	virtual void * GetParameter() { return fParameter; }
    void	SetTypeId();
    void	SetParameter (T *par);
    void	SetParameterF(T *par);
    void	SetParameterVal_t(double *par);
    virtual string str() const;

protected:
    T *fParameter;

private:
    GCommandLineArgument();
    GCommandLineArgument(const GCommandLineArgument &);
    GCommandLineArgument  & operator = (GCommandLineArgument  &  rhs)
    {
        fParameter = reinterpret_cast<T *>(rhs.GetParameter());
        return *this;
    }
};



template<class T>
inline GCommandLineArgument<T>::~GCommandLineArgument()
{
    /*
    if (!std::is_fundamental<T>::value )
    {
        delete fParameter;
    }
    */
}



template <class T>
void GCommandLineArgument<T>::SetTypeId()
{
    fTypeId = typeid(T).name();
    if (
        std::is_base_of< Val_t<double>, T >::value ||
        std::is_base_of< Val_t<long double>, T >::value ||
        std::is_base_of< Val_t<float>, T >::value ||
        std::is_base_of< Val_t<short>, T >::value ||
        std::is_base_of< Val_t<int>, T >::value ||
        std::is_base_of< Val_t<long>, T >::value ||
        std::is_base_of< Val_t<long long>, T >::value ||
        std::is_base_of< Val_t<unsigned short>, T >::value ||
        std::is_base_of< Val_t<unsigned int>, T >::value ||
        std::is_base_of< Val_t<unsigned long int>, T >::value ||
        std::is_base_of< Val_t<unsigned char>, T >::value ||
        std::is_base_of< Val_t<char>, T >::value
        //  std::is_base_of< Val_t<uint8_t>, T >::value
        )
    {
        fTypeIdBase = "Val_t";
    }
    else
    {
        // fTypeIdBase = "Val_t"; 
        // fTypeIdBase = "xxxxuknown Val_t basetypexxxx";
    }
}



template <class T>
string GCommandLineArgument<T>::str() const
{
    std::stringstream buffer;  
    buffer << GArgument::str() << endl;
    return buffer.str();	
}



template<class T>
//template<typename U>
inline void GCommandLineArgument<T>::SetParameter(T * par)
{
    if (par == 0)
    {
        //G_ERROR("Parameter \"par\" is a ZERO pointer");
    }
    else
    {

        if (typeid(T).name() == typeid(string).name())
        {
            *fParameter = *par;
        }
        else
        {
            for (unsigned int i = 0; i < par->size(); i++)
            {
                if (fParameter != 0) {
                    fParameter->push_back((*par)[i]);
                }
                else
                {
         //        /  fprintf_s(fp, "Argument to parameter %s is a ZERO pointer (this might not be an error), no parameter(s) added", fCmd->c_str());
                //   G_INFO("Argument to parameter %s is a ZERO pointer (this might not be an error), no parameter(s) added", fCmd->c_str());
                }
            }
        }
    }
}



template<class T>
inline void GCommandLineArgument<T>::SetParameterF(T * par)
{
    if (fParameter != 0)
    {
        T tmp = (T)(*par);
        *fParameter = tmp;
    }
    else
    {
        G_INFO("GArgument is ZERO, nothing added");
    }
}


template<class T>
inline void
GCommandLineArgument<T>::SetParameterVal_t(double *par)
{
    if( par != 0 )
    {
       fParameter->SetValue(*par);
    }
}    



#endif

